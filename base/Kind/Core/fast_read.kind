Kind.Core.read.term(code: String): Pair<String, List<Pair<String,Kind.Term>> -> Kind.Term>
  let {code, skip} = Kind.Core.read.spaces(code)
  case code {
    nil:
      {"", (ctx) Kind.Term.ref("error")}
    cons:
      let head = code.head
      let code = code.tail
      if Char.eql(head, '*') then
        {code, (ctx) Kind.Term.typ}
      else if U16.eql(head, '@') then
        let {code, self} = Kind.Core.read.name(code)
        let {code, skip} = Kind.Core.read.char(code, '(')
        let {code, name} = Kind.Core.read.name(code)
        let {code, skip} = Kind.Core.read.char(code, ':')
        let {code, bind} = Kind.Core.read.term(code)
        let {code, skip} = Kind.Core.read.char(code, ')')
        let {code, body} = Kind.Core.read.term(code)
        {code, (ctx) Kind.Term.all(false, self, name, bind(ctx), (s,x) body({name,x}&{self,s}&ctx))}
      else if U16.eql(head, '%') then
        let {code, self} = Kind.Core.read.name(code)
        let {code, skip} = Kind.Core.read.char(code, '(')
        let {code, name} = Kind.Core.read.name(code)
        let {code, skip} = Kind.Core.read.char(code, ':')
        let {code, bind} = Kind.Core.read.term(code)
        let {code, skip} = Kind.Core.read.char(code, ')')
        let {code, body} = Kind.Core.read.term(code)
        {code, (ctx) Kind.Term.all(true, self, name, bind(ctx), (s,x) body({name,x}&{self,s}&ctx))}
      else if U16.eql(head, '#') then
        let {code, name} = Kind.Core.read.name(code)
        let {code, body} = Kind.Core.read.term(code)
        {code, (ctx) Kind.Term.lam(name, (x) body({name,x} & ctx))}
      else if U16.eql(head, '(') then
        let {code, func} = Kind.Core.read.term(code)
        let {code, argm} = Kind.Core.read.term(code)
        let {code, skip} = Kind.Core.read.char(code, ')')
        {code, (ctx) Kind.Term.app(func(ctx), argm(ctx))}
      else if U16.eql(head, '!') then
        let {code, name} = Kind.Core.read.name(code)
        let {code, skip} = Kind.Core.read.char(code, '=')
        let {code, expr} = Kind.Core.read.term(code)
        let {code, skip} = Kind.Core.read.char(code, ';')
        let {code, body} = Kind.Core.read.term(code)
        {code, (ctx) Kind.Term.let(name, expr(ctx), (x) body({name,x} & ctx))}
      else if U16.eql(head, '$') then
        let {code, name} = Kind.Core.read.name(code)
        let {code, skip} = Kind.Core.read.char(code, '=')
        let {code, expr} = Kind.Core.read.term(code)
        let {code, skip} = Kind.Core.read.char(code, ';')
        let {code, body} = Kind.Core.read.term(code)
        {code, (ctx) Kind.Term.def(name, expr(ctx), (x) body({name,x} & ctx))}
      else if U16.eql(head, '{') then
        let {code, expr} = Kind.Core.read.term(code)
        let {code, skip} = Kind.Core.read.char(code, ':')
        let {code, type} = Kind.Core.read.term(code)
        let {code, skip} = Kind.Core.read.char(code, '}')
        {code, (ctx) Kind.Term.ann(false, expr(ctx), type(ctx))}
      else if U16.eql(head, '\'') then
        let {code, chrx} = Kind.Core.read.chrx(code)
        let {code, skip} = Kind.Core.read.char(code, '\'')
        {code, (ctx) Kind.Term.chr(chrx)}
      else if U16.eql(head, '"') then
        let {code, strx} = Kind.Core.read.strx(code)
        let {code, skip} = Kind.Core.read.char(code, '"')
        {code, (ctx) Kind.Term.str(strx)}
      else if U16.eql(head, '+') then
        let {code, natx} = Kind.Core.read.natx(code, 0)
        {code, (ctx) Kind.Term.nat(natx)}
      else
        if Kind.Core.read.is_name(head) then
          let {code, name} = Kind.Core.read.name(code)
          let name = String.cons(head, name)
          let {code, brui} = case code {
            nil: {"", 0}
            cons: if U16.eql(code.head,'^')
              then Kind.Core.read.natx(code.tail, 0)
              else {code, 0}
          }
          {code, (ctx)
            def fun = (x,i) String.eql(Pair.fst!!(x), name)
            let got = Kind.Core.read.find!(ctx, fun, 0, brui)
            case got {
              some: Pair.snd!!(Pair.fst!!(got.value))
              none: Kind.Term.ref(name)
            }}
        else
          {"", (ctx) Kind.Term.ref("error")}
  }

Kind.Core.fast_read(code: String): Maybe<Kind.Term>
  let {code, term} = Kind.Core.read.term(code | ";")
  case code {
    nil: none
    cons: some(term([]))
  }
